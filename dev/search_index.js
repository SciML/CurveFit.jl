var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Problem-Types","page":"API Reference","title":"Problem Types","text":"","category":"section"},{"location":"api/#Algorithms","page":"API Reference","title":"Algorithms","text":"","category":"section"},{"location":"api/#Solutions","page":"API Reference","title":"Solutions","text":"","category":"section"},{"location":"api/#Common-Interface","page":"API Reference","title":"Common Interface","text":"","category":"section"},{"location":"api/#CurveFit.CurveFitProblem","page":"API Reference","title":"CurveFit.CurveFitProblem","text":"CurveFitProblem(x, y; nlfunc=nothing, u0=nothing)\n\nRepresents a curve fitting problem where x and y are the data points to fit.\n\nCertain algorithms may require an initial guess u0 for the coefficients to fit. See specific solver documentation for more details.\n\nSee also NonlinearCurveFitProblem.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.NonlinearCurveFitProblem","page":"API Reference","title":"CurveFit.NonlinearCurveFitProblem","text":"NonlinearCurveFitProblem(f, u0, x, y)\n\nNonlinear curve fitting problem where f is a nonlinear function to fit, u0 is the initial guess for the coefficients, and x and y are the data points to fit. The following optimization problem is solved:\n\nargmin_u  left f(u x) - y right_2\n\nIf y is nothing, then it is treated as a zero vector. f is a generic Julia function or ideally a NonlinearFunction from SciMLBase.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.LinearCurveFitAlgorithm","page":"API Reference","title":"CurveFit.LinearCurveFitAlgorithm","text":"LinearCurveFitAlgorithm(;\n    xfun = identity, yfun = identity, yfun_inverse = inverse(yfun)\n)\n\nRepresents a linear curve fitting algorithm where x and y are the data points to fit. We want to solve for a and b such that:\n\nf_y(y) = a f_x(x) + b\n\nwhere f_x corresponds to xfun and f_y corresponds to yfun. Note that this is a general problem specification of a curve fitting problem which can be converted to a linear fit in a specific function space by choosing appropriate xfun and yfun. The yfun_inverse is used to convert the fitted values back to the original space (can be specified by defining InverseFunctions.inverse).\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.PolynomialFitAlgorithm","page":"API Reference","title":"CurveFit.PolynomialFitAlgorithm","text":"PolynomialFitAlgorithm(degree::Int)\nPolynomialFitAlgorithm(;\n    degree::Int,\n    linsolve_algorithm::Union{Nothing, AbstractLinearAlgorithm} = nothing\n)\n\nRepresents a polynomial fitting algorithm of degree degree. Only applicable to LinearCurveFitAlgorithms.\n\ntip: Tip\nFor ill-conditioned problems, it is recommended to use linear solvers like QRFactorization. Alternatively, pass in assumptions = OperatorAssumptions(false; condition = OperatorsCondition.<condition>) to solve/init.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.LogCurveFitAlgorithm","page":"API Reference","title":"CurveFit.LogCurveFitAlgorithm","text":"LogCurveFitAlgorithm()\n\nRepresents a log curve fitting algorithm where x and y are the data points to fit. We want to solve for a and b such that:\n\ny = a log(x) + b\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.PowerCurveFitAlgorithm","page":"API Reference","title":"CurveFit.PowerCurveFitAlgorithm","text":"PowerCurveFitAlgorithm()\n\nRepresents a power curve fitting algorithm where x and y are the data points to fit. We want to solve for a and b such that:\n\ny = b x^a\n\nThis is equivalent to a linear fit in log-log space, i.e.,\n\nlog(y) = a log(x) + log(b)\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.ExpCurveFitAlgorithm","page":"API Reference","title":"CurveFit.ExpCurveFitAlgorithm","text":"ExpCurveFitAlgorithm()\n\nRepresents an exponential curve fitting algorithm where x and y are the data points to fit. We want to solve for a and b such that:\n\ny = b exp(a x)\n\nThis is equivalent to a linear fit in log-linear space, i.e.,\n\nlog(y) = a x + log(b)\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.RationalPolynomialFitAlgorithm","page":"API Reference","title":"CurveFit.RationalPolynomialFitAlgorithm","text":"RationalPolynomialFitAlgorithm(num_degree::Int, den_degree::Int)\nRationalPolynomialFitAlgorithm(;\n    num_degree::Int, den_degree::Int, alg = nothing\n)\n\nRepresents a rational polynomial fitting algorithm with numerator degree num_degree and denominator degree den_degree. The internal polynomial fitting algorithm is determined by the alg keyword argument. If alg is nothing or a AbstractNonlinearAlgorithm (like solvers from NonlinearSolve.jl), it will use a nonlinear curve fitting approach. If alg is a AbstractLinearAlgorithm, it will use linear least squares fitting.\n\nLinear Rational Polynomial Fitting\n\nIn this case the following curve fit is done:\n\ny = fracp(x)q(x)\n\nwhere p(x) is a polynomial of degree num_degree and q(x) is a polynomial of degree den_degree. The linear case is solved by doing a least squares fit on:\n\ny q(x) = p(x)\n\nwhere the zero order term of q(x) is assumed to be 1.\n\nNonlinear Rational Polynomial Fitting\n\nIf an u0 is not provided to the problem, then we will use linear least squares for an initial guess.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.KingCurveFitAlgorithm","page":"API Reference","title":"CurveFit.KingCurveFitAlgorithm","text":"KingCurveFitAlgorithm()\n\nRepresents a king curve fitting problem where x and y are the data points to fit. We want to solve for a and b according to original King's law (1910) that represents the relationship between voltage (E) and velocity (U) in a hotwire anemometer:\n\nE^2 = A + B U^12\n\nor\n\nx^2 = A + B y^12\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.ModifiedKingCurveFitAlgorithm","page":"API Reference","title":"CurveFit.ModifiedKingCurveFitAlgorithm","text":"ModifiedKingCurveFitAlgorithm(alg::Union{Nothing, AbstractNonlinearAlgorithm} = nothing)\n\nSimilar to KingCurveFitAlgorithm, but uses the modified King's law:\n\nE^2 = A + B U^n\n\nwhere n is also a parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.ExpSumFitAlgorithm","page":"API Reference","title":"CurveFit.ExpSumFitAlgorithm","text":"ExpSumFitAlgorithm(; n::Int, m::Int = 1, withconst::Bool = true)\n\nFits the sum of n exponentials and a constant.\n\ny = k + p_1 e^λ_1 t + p_2 e^λ_2 t +  + p_n e^λ_n t\n\nIf the keyword withconst is set to false, the constant is not fitted but set k=0.\n\nUses numerical integration with m strips, where the default m=1 uses linear interpolation. m=2 and higher require uniform interval and usually lead to better accuracy.\n\nThis algorithm is from Matlab code of Juan Gonzales Burgos.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.CurveFitSolution","page":"API Reference","title":"CurveFit.CurveFitSolution","text":"CurveFitSolution(alg, coeffs, prob)\n\nRepresents the solution to a curve fitting problem. This is a callable struct and can be used to evaluate the solution at a point. Exact evaluation mechanism depends on the algorithm used to solve the problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonSolve.solve","page":"API Reference","title":"CommonSolve.solve","text":"CommonSolve.solve(args...; kwargs...)\n\nSolves an equation or other mathematical problem using the algorithm specified in the arguments. Generally, the interface is:\n\nCommonSolve.solve(prob::ProblemType, alg::SolverType; kwargs...)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms.\n\nBy default, solve defaults to using solve! on the iterator form, i.e.:\n\nsolve(args...; kwargs...) = solve!(init(args...; kwargs...))\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonSolve.solve!","page":"API Reference","title":"CommonSolve.solve!","text":"CommonSolve.solve!(iter)\n\nSolves an equation or other mathematical problem using the algorithm specified in the arguments. Generally, the interface is:\n\niter = CommonSolve.init(prob::ProblemType, alg::SolverType; kwargs...)::IterType\nCommonSolve.solve!(iter)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms. The iter type will be different for the different problem types.\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonSolve.init","page":"API Reference","title":"CommonSolve.init","text":"iter = CommonSolve.init(args...; kwargs...)\n\nCreates an iterator or cache object to hold a problem prob and a solver algorithm alg to be passed to solve! or step!. Generally, the interface is:\n\niter = CommonSolve.init(prob::ProblemType, alg::SolverType; kwargs...)::IterType\nCommonSolve.solve!(iter)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms. The iter type will be different for the different problem types.\n\nThe object returned by init allows more direct control over the internal solving process, and users shouldn't generally need to handle it.\n\n\n\n\n\n","category":"function"},{"location":"#CurveFit.jl","page":"Home","title":"CurveFit.jl","text":"Linear, special function, and nonlinear curve fitting in Julia.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"CurveFit\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Linear-Fitting","page":"Home","title":"Linear Fitting","text":"Fit a linear function y = a * x + b:\n\nusing CurveFit\n\n# Generate sample data: y = 2.5 * x + 3.0\nx = collect(0:0.1:10)\ny = @. 2.5 * x + 3.0\n\n# Create the problem and solve\nprob = CurveFitProblem(x, y)\nsol = solve(prob, LinearCurveFitAlgorithm())\n\n# Access the coefficients: sol.u = (a, b)\nprintln(\"Slope (a): \", sol.u[1])\nprintln(\"Intercept (b): \", sol.u[2])\n\n# Evaluate the solution at a point\nprintln(\"Prediction at x=5: \", sol(5.0))","category":"section"},{"location":"#Polynomial-Fitting","page":"Home","title":"Polynomial Fitting","text":"Fit a polynomial of a given degree:\n\nusing CurveFit\n\n# Generate sample data: y = 1.0 + 2.0*x + 3.0*x^2\nx = collect(range(1, stop=10, length=20))\ny = @. 1.0 + 2.0 * x + 3.0 * x^2\n\n# Create the problem and solve with degree 2 polynomial\nprob = CurveFitProblem(x, y)\nsol = solve(prob, PolynomialFitAlgorithm(degree=2))\n\n# Access the coefficients: [c0, c1, c2] for c0 + c1*x + c2*x^2\nprintln(\"Coefficients: \", sol.u)\n\n# Evaluate the solution at a point\nprintln(\"Prediction at x=5: \", sol(5.0))","category":"section"},{"location":"#Exponential-Fitting","page":"Home","title":"Exponential Fitting","text":"Fit an exponential function y = b * exp(a * x):\n\nusing CurveFit\n\n# Generate sample data: y = 2.0 * exp(0.3 * x)\nx = collect(range(0, stop=5, length=20))\ny = @. 2.0 * exp(0.3 * x)\n\nprob = CurveFitProblem(x, y)\nsol = solve(prob, ExpCurveFitAlgorithm())\n\n# sol.u[1] = a (exponent coefficient)\n# sol.u[2] = log(b)\nprintln(\"Exponent coefficient (a): \", sol.u[1])\nprintln(\"Scale factor (b): \", exp(sol.u[2]))","category":"section"},{"location":"#Power-Law-Fitting","page":"Home","title":"Power Law Fitting","text":"Fit a power law y = b * x^a:\n\nusing CurveFit\n\n# Generate sample data: y = 2.0 * x^0.8\nx = collect(range(1, stop=10, length=20))\ny = @. 2.0 * x^0.8\n\nprob = CurveFitProblem(x, y)\nsol = solve(prob, PowerCurveFitAlgorithm())\n\n# sol.u[1] = a (exponent)\n# sol.u[2] = log(b)\nprintln(\"Exponent (a): \", sol.u[1])\nprintln(\"Scale factor (b): \", exp(sol.u[2]))","category":"section"},{"location":"#Nonlinear-Curve-Fitting","page":"Home","title":"Nonlinear Curve Fitting","text":"For arbitrary nonlinear functions, use NonlinearCurveFitProblem:\n\nusing CurveFit\n\n# Define a nonlinear function: y = a[1] + a[2] * x^a[3]\nfn(a, x) = @. a[1] + a[2] * x^a[3]\n\n# True parameters\ntrue_params = [3.0, 2.0, 0.7]\n\n# Generate sample data\nx = collect(1.0:0.5:10.0)\ny = fn(true_params, x)\n\n# Create problem with initial guess for parameters\nu0 = [0.5, 0.5, 0.5]\nprob = NonlinearCurveFitProblem(fn, u0, x, y)\nsol = solve(prob)\n\nprintln(\"Fitted parameters: \", sol.u)\nprintln(\"Prediction at x=5: \", sol(5.0))","category":"section"},{"location":"#Sum-of-Exponentials","page":"Home","title":"Sum of Exponentials","text":"Fit a sum of exponentials: y = k + p * exp(λ * t):\n\nusing CurveFit\n\n# Generate sample data: y = 2.0 + 3.0*exp(-0.5*t)\nt = collect(range(0, stop=10, length=50))\ny = @. 2.0 + 3.0 * exp(-0.5 * t)\n\nprob = CurveFitProblem(t, y)\nsol = solve(prob, ExpSumFitAlgorithm(n=1, withconst=true))\n\n# Access fitted parameters (returned as arrays for n exponentials)\n# k[] extracts the scalar from a 1-element array\nprintln(\"Constant (k): \", sol.u.k[])\nprintln(\"Amplitude (p): \", sol.u.p[])\nprintln(\"Decay rate (λ): \", sol.u.λ[])","category":"section"},{"location":"#API","page":"Home","title":"API","text":"See the API Reference page for detailed documentation of all exported functions.","category":"section"}]
}
