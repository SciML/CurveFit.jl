<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · CurveFit.jl</title><meta name="title" content="Solvers · CurveFit.jl"/><meta property="og:title" content="Solvers · CurveFit.jl"/><meta property="twitter:title" content="Solvers · CurveFit.jl"/><meta name="description" content="Documentation for CurveFit.jl."/><meta property="og:description" content="Documentation for CurveFit.jl."/><meta property="twitter:description" content="Documentation for CurveFit.jl."/><meta property="og:url" content="https://docs.sciml.ai/CurveFit/stable/basics/solvers/"/><meta property="twitter:url" content="https://docs.sciml.ai/CurveFit/stable/basics/solvers/"/><link rel="canonical" href="https://docs.sciml.ai/CurveFit/stable/basics/solvers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CurveFit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/getting_started/">Getting started with CurveFit.jl</a></li><li><a class="tocitem" href="../../tutorials/linsolve_choice/">Advanced usage</a></li><li><a class="tocitem" href="../../tutorials/stats/">StatsAPI interface usage</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../overview/">Basic overview</a></li><li><a class="tocitem" href="../problems/">Problem types</a></li><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#Linear-fitting"><span>Linear fitting</span></a></li><li><a class="tocitem" href="#Nonlinear-fitting"><span>Nonlinear fitting</span></a></li><li><a class="tocitem" href="#Special-functions"><span>Special functions</span></a></li></ul></li><li><a class="tocitem" href="../solutions/">Solutions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/CurveFit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/CurveFit.jl/blob/master/docs/src/basics/solvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h1><p>CurveFit provides built-in solvers for linear curve fitting problems. Nonlinear problems are delegated to <code>NonlinearSolve.jl</code>. In addition, CurveFit includes specialized algorithms for selected nonstandard models.</p><h2 id="Linear-fitting"><a class="docs-heading-anchor" href="#Linear-fitting">Linear fitting</a><a id="Linear-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-fitting" title="Permalink"></a></h2><p>Linear curve fitting in CurveFit solves problems of the general form $ f<em>y(y) = a \cdot f</em>x(x) + b $ where <code>x</code> and <code>y</code> are the data points being fitted and <code>a</code> and <code>b</code> are the fit parameters.</p><p>Linear fits do not require an initial guess. The user must explicitly select a linear algorithm, as no default is assumed.</p><p>Linear fitting algorithms are represented by the <code>LinearCurveFitAlgorithm</code> type, which encapsulates transformations applied to the input and output data. The fields <code>xfun</code> and <code>yfun</code> define transformations applied to <code>x</code> and <code>y</code>, respectively, while <code>yfun_inverse</code> maps fitted parameters back to the original data space.</p><p>The default constructor corresponds to the standard linear model $ y = a \cdot x + b $ where both transformations are identity functions. Users may supply custom transformations to define alternative linear relationships. The inverse transformation is computed using <code>InverseFunctions.jl</code>.</p><p>These are the convenience constructors exported by CurveFit used for defining some linear curve fitting algorithms:</p><article><details class="docstring" open="true"><summary id="CurveFit.LinearCurveFitAlgorithm"><a class="docstring-binding" href="#CurveFit.LinearCurveFitAlgorithm"><code>CurveFit.LinearCurveFitAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearCurveFitAlgorithm(;
    xfun = identity, yfun = identity, yfun_inverse = inverse(yfun)
)</code></pre><p>Represents a linear curve fitting algorithm where <code>x</code> and <code>y</code> are the data points to fit. We want to solve for <code>a</code> and <code>b</code> such that:</p><p class="math-container">\[f_y(y) = a f_x(x) + b\]</p><p>where <span>$f_x$</span> corresponds to <code>xfun</code> and <span>$f_y$</span> corresponds to <code>yfun</code>. Note that this is a general problem specification of a curve fitting problem which can be converted to a linear fit in a specific function space by choosing appropriate <code>xfun</code> and <code>yfun</code>. The <code>yfun_inverse</code> is used to convert the fitted values back to the original space (can be specified by defining <code>InverseFunctions.inverse</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L174-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CurveFit.LogCurveFitAlgorithm"><a class="docstring-binding" href="#CurveFit.LogCurveFitAlgorithm"><code>CurveFit.LogCurveFitAlgorithm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">LogCurveFitAlgorithm()</code></pre><p>Represents a log curve fitting algorithm where <code>x</code> and <code>y</code> are the data points to fit. We want to solve for <code>a</code> and <code>b</code> such that:</p><p class="math-container">\[y = a \log(x) + b\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CurveFit.PowerCurveFitAlgorithm"><a class="docstring-binding" href="#CurveFit.PowerCurveFitAlgorithm"><code>CurveFit.PowerCurveFitAlgorithm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">PowerCurveFitAlgorithm()</code></pre><p>Represents a power curve fitting algorithm where <code>x</code> and <code>y</code> are the data points to fit. We want to solve for <code>a</code> and <code>b</code> such that:</p><p class="math-container">\[y = b x^a\]</p><p>This is equivalent to a linear fit in log-log space, i.e.,</p><p class="math-container">\[\log(y) = a \log(x) + \log(b)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CurveFit.ExpCurveFitAlgorithm"><a class="docstring-binding" href="#CurveFit.ExpCurveFitAlgorithm"><code>CurveFit.ExpCurveFitAlgorithm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ExpCurveFitAlgorithm()</code></pre><p>Represents an exponential curve fitting algorithm where <code>x</code> and <code>y</code> are the data points to fit. We want to solve for <code>a</code> and <code>b</code> such that:</p><p class="math-container">\[y = b \exp(a x)\]</p><p>This is equivalent to a linear fit in log-linear space, i.e.,</p><p class="math-container">\[\log(y) = a x + \log(b)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CurveFit.KingCurveFitAlgorithm"><a class="docstring-binding" href="#CurveFit.KingCurveFitAlgorithm"><code>CurveFit.KingCurveFitAlgorithm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">KingCurveFitAlgorithm()</code></pre><p>Represents a king curve fitting problem where <code>x</code> and <code>y</code> are the data points to fit. We want to solve for <code>a</code> and <code>b</code> according to original King&#39;s law (1910) that represents the relationship between voltage (E) and velocity (U) in a hotwire anemometer:</p><p class="math-container">\[E^2 = A + B U^{1/2}\]</p><p>or</p><p class="math-container">\[x^2 = A + B y^{1/2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L246">source</a></section></details></article><h2 id="Nonlinear-fitting"><a class="docs-heading-anchor" href="#Nonlinear-fitting">Nonlinear fitting</a><a id="Nonlinear-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-fitting" title="Permalink"></a></h2><p>Nonlinear curve fitting problems are solved through NonlinearSolve.jl. The user defines  a nonlinear problem using <code>NonlinearCurveFitProblem</code>, supplying a model function and an  initial guess for the parameters.</p><p>During initialization, CurveFit detects nonlinear problems by checking if a model function is provided and internally constructs a <code>NonlinearLeastSquaresProblem</code>, which is then passed  to NonlinearSolve.jl for solution. For details, see the documentation for <a href="https://docs.sciml.ai/NonlinearSolve/stable/basics/nonlinear_problem/">NonlinearLeastSquaresProblem</a>.</p><p>By default, NonlinearSolve.jl automatically selects an appropriate nonlinear least-squares algorithm. Advanced users may explicitly specify a solver, such as <code>LevenbergMarquardt</code> or <code>GaussNewton</code>. Documentation for available solvers can be found <a href="https://docs.sciml.ai/NonlinearSolve/stable/solvers/nonlinear_least_squares_solvers/">here</a>.</p><p>For more details, see <a href="../../tutorials/linsolve_choice/#Advanced-usage">Advanced usage</a>.</p><h2 id="Special-functions"><a class="docs-heading-anchor" href="#Special-functions">Special functions</a><a id="Special-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Special-functions" title="Permalink"></a></h2><p>CurveFit provides specialized algorithms for fitting selected classes of nonlinear models with known structure. These algorithms exploit problem-specific properties to improve robustness and performance compared to fully generic nonlinear least-squares approaches.</p><h3 id="Modified-King-fitting"><a class="docs-heading-anchor" href="#Modified-King-fitting">Modified King fitting</a><a id="Modified-King-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Modified-King-fitting" title="Permalink"></a></h3><p>The Modified King fit algorithm is designed for the model function of the form:</p><p class="math-container">\[x^2 = a + b \cdot y^n\]</p><p>Unlike the linear King fit where the exponent is a constant (1/2), <code>n</code> in the exponent is  a coefficient and thus the problem becomes nonlinear. Since it is nonlinear solving it is done via NonlinearSolve.jl. This Modified King fit has a defined model and if the user tries  to solve a problem with a specified model function using this algorithm an error will be thrown. However, the user can pass an initial guess for the coefficients <code>a</code>, <code>b</code> and <code>n</code>. In case an initial guess is not provided CurveFit will obatin it internally by using the related linear King fit.</p><article><details class="docstring" open="true"><summary id="CurveFit.ModifiedKingCurveFitAlgorithm"><a class="docstring-binding" href="#CurveFit.ModifiedKingCurveFitAlgorithm"><code>CurveFit.ModifiedKingCurveFitAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ModifiedKingCurveFitAlgorithm(alg::Union{Nothing, AbstractNonlinearAlgorithm} = nothing)</code></pre><p>Similar to <a href="#CurveFit.KingCurveFitAlgorithm"><code>KingCurveFitAlgorithm</code></a>, but uses the modified King&#39;s law:</p><p class="math-container">\[E^2 = A + B U^n\]</p><p>where <code>n</code> is also a parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L265">source</a></section></details></article><h3 id="Sum-of-exponentials-fitting"><a class="docs-heading-anchor" href="#Sum-of-exponentials-fitting">Sum of exponentials fitting</a><a id="Sum-of-exponentials-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Sum-of-exponentials-fitting" title="Permalink"></a></h3><p>The sum of exponentials fitting algorithm is defined for models of the form:</p><p class="math-container">\[y = k + \sum_{i=1}^{n} p_i \exp(\lambda_i x)\]</p><p>The number of exponential terms is specified by the user. This method exploits the algebraic  structure of exponential sums to avoid solving a nonlinear problem. By computing discrete  cumulative integrals of the data, the problem is transformed into a linear recurrence  whose coefficients can be estimated using linear least squares. The exponential rates  (\lambda_i) are then recovered as eigenvalues of a matrix derived from this recurrence.</p><p>Once the rates are known, the amplitudes (p_i) and the optional constant term (k) are obtained by solving a linear least squares problem with fixed exponential basis functions.</p><p>For more details see <a href="https://math.stackexchange.com/questions/1428566/fit-sum-of-exponentials">here</a>.</p><article><details class="docstring" open="true"><summary id="CurveFit.ExpSumFitAlgorithm"><a class="docstring-binding" href="#CurveFit.ExpSumFitAlgorithm"><code>CurveFit.ExpSumFitAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExpSumFitAlgorithm(; n::Int, m::Int = 1, withconst::Bool = true)</code></pre><p>Fits the sum of <code>n</code> exponentials and a constant.</p><p class="math-container">\[y = k + p_1 e^{λ_1 t} + p_2 e^{λ_2 t} + ⋯ + p_n e^{λ_n t}\]</p><p>If the keyword <code>withconst</code> is set to <code>false</code>, the constant is not fitted but set <code>k=0</code>.</p><p>Uses numerical integration with <code>m</code> strips, where the default <code>m=1</code> uses linear interpolation. <code>m=2</code> and higher require uniform interval and usually lead to better accuracy.</p><p>This algorithm is from <a href="https://github.com/juangburgos/FitSumExponentials">Matlab code of Juan Gonzales Burgos</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L349">source</a></section></details></article><h3 id="Polynomial-fitting"><a class="docs-heading-anchor" href="#Polynomial-fitting">Polynomial fitting</a><a id="Polynomial-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-fitting" title="Permalink"></a></h3><h4 id="Standard"><a class="docs-heading-anchor" href="#Standard">Standard</a><a id="Standard-1"></a><a class="docs-heading-anchor-permalink" href="#Standard" title="Permalink"></a></h4><p>Polynomial fitting solves problems of the form</p><p class="math-container">\[y = \sum_{k=0}^{n} a_k x^k\]</p><p>The polynomial degree is specified by the user. The problem is formulated as  a <code>LinearProblem</code> using a Vandermonde matrix constructed from the input data The polynomial coefficients are obtained by solving this linear system with a user-selectable linear solver. </p><p>Polynomial fitting is only applicable to linear curve fitting problems and does not support user-provided initial guesses. It is recommended to use numerically stable solvers such as QR-based factorizations. CurveFit allows the linear solver to be customized via the <code>linsolve_algorithm</code> field of <code>PolynomialFitAlgorithm</code>.</p><article><details class="docstring" open="true"><summary id="CurveFit.PolynomialFitAlgorithm"><a class="docstring-binding" href="#CurveFit.PolynomialFitAlgorithm"><code>CurveFit.PolynomialFitAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolynomialFitAlgorithm(degree::Int)
PolynomialFitAlgorithm(;
    degree::Int,
    linsolve_algorithm::Union{Nothing, AbstractLinearAlgorithm} = nothing
)</code></pre><p>Represents a polynomial fitting algorithm of degree <code>degree</code>. Only applicable to <a href="#CurveFit.LinearCurveFitAlgorithm"><code>LinearCurveFitAlgorithm</code></a>s.</p><div class="admonition is-success" id="Tip-fb34951b0115ed3b"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-fb34951b0115ed3b" title="Permalink"></a></header><div class="admonition-body"><p>For ill-conditioned problems, it is recommended to use linear solvers like <code>QRFactorization</code>. Alternatively, pass in <code>assumptions = OperatorAssumptions(false; condition = OperatorsCondition.&lt;condition&gt;)</code> to <code>solve</code>/<code>init</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L280">source</a></section></details></article><h4 id="Rational"><a class="docs-heading-anchor" href="#Rational">Rational</a><a id="Rational-1"></a><a class="docs-heading-anchor-permalink" href="#Rational" title="Permalink"></a></h4><p>Rational polynomial fitting solves problems of the form</p><p class="math-container">\[y = \frac{p(x)}{q(x)}\]</p><p>(p(x)) and (q(x)) are polynomials of user-specified degrees. The constant term of the denominator is assumed to be 1. Rational polynomial fitting implements both linear and nonlinear methods. <code>RationalPolynomialFitAlgorithm</code> has three fields,  the first two are degrees of the numerator and denominator and third is the <code>alg</code> field which contains the algorithm used for solving the problem.</p><p>In case the user chooses a linear fit algorithm initial guesses are not supported. The problem is transformed into <span>$y \cdot q(x) = p(x)$</span>. This linearized problem is then solved by creating linear fit cache with <code>LinearProblem</code> which is then handled by the internal solver for linear rational fit of CurveFit. For more detail on <code>Linear problem</code> <a href="https://docs.sciml.ai/LinearSolve/stable/basics/LinearProblem/">see</a>.</p><p>If the user chooses a nonlinear algorithm, then the problem is solved via NonlinearSolve.jl. In this case the user can provide an initial guess. If it is not provided, then CurveFit will obtain one from the linear rational fit.</p><article><details class="docstring" open="true"><summary id="CurveFit.RationalPolynomialFitAlgorithm"><a class="docstring-binding" href="#CurveFit.RationalPolynomialFitAlgorithm"><code>CurveFit.RationalPolynomialFitAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RationalPolynomialFitAlgorithm(num_degree::Int, den_degree::Int)
RationalPolynomialFitAlgorithm(;
    num_degree::Int, den_degree::Int, alg = nothing
)</code></pre><p>Represents a rational polynomial fitting algorithm with numerator degree <code>num_degree</code> and denominator degree <code>den_degree</code>. The internal polynomial fitting algorithm is determined by the <code>alg</code> keyword argument. If <code>alg</code> is <code>nothing</code> or a <code>AbstractNonlinearAlgorithm</code> (like solvers from NonlinearSolve.jl), it will use a nonlinear curve fitting approach. If <code>alg</code> is a <code>AbstractLinearAlgorithm</code>, it will use linear least squares fitting.</p><p><strong>Linear Rational Polynomial Fitting</strong></p><p>In this case the following curve fit is done:</p><p class="math-container">\[y = \frac{p(x)}{q(x)}\]</p><p>where <code>p(x)</code> is a polynomial of degree <code>num_degree</code> and <code>q(x)</code> is a polynomial of degree <code>den_degree</code>. The linear case is solved by doing a least squares fit on:</p><p class="math-container">\[y q(x) = p(x)\]</p><p>where the zero order term of <code>q(x)</code> is assumed to be 1.</p><p><strong>Nonlinear Rational Polynomial Fitting</strong></p><p>If an <code>u0</code> is not provided to the problem, then we will use linear least squares for an initial guess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CurveFit.jl/blob/dfbaf0833d2134c19137143f132e5dcdd1dfd462/src/common_interface.jl#L304-L338">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problems/">« Problem types</a><a class="docs-footer-nextpage" href="../solutions/">Solutions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 12 January 2026 22:06">Monday 12 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
