var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Problem-Types","page":"API","title":"Problem Types","text":"","category":"section"},{"location":"api/#CurveFit.CurveFitProblem","page":"API","title":"CurveFit.CurveFitProblem","text":"CurveFitProblem(x, y; nlfunc=nothing, u0=nothing)\n\nRepresents a curve fitting problem where x and y are the data points to fit.\n\nCertain algorithms may require an initial guess u0 for the coefficients to fit. See specific solver documentation for more details.\n\nSee also NonlinearCurveFitProblem.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.NonlinearCurveFitProblem","page":"API","title":"CurveFit.NonlinearCurveFitProblem","text":"NonlinearCurveFitProblem(f, u0, x, y)\n\nNonlinear curve fitting problem where f is a nonlinear function to fit, u0 is the initial guess for the coefficients, and x and y are the data points to fit. The following optimization problem is solved:\n\nbeginequation\n    undersetutextargmin   f(u x) - y _2\nendequation\n\nIf y is nothing, then it is treated as a zero vector. f is a generic Julia function or ideally a NonlinearFunction from SciMLBase.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#Algorithms","page":"API","title":"Algorithms","text":"","category":"section"},{"location":"api/#CurveFit.LinearCurveFitAlgorithm","page":"API","title":"CurveFit.LinearCurveFitAlgorithm","text":"LinearCurveFitAlgorithm(;\n    xfun = identity, yfun = identity, yfun_inverse = inverse(yfun)\n)\n\nRepresents a linear curve fitting algorithm where x and y are the data points to fit. We want to solve for a and b such that:\n\nyfun(y) = a * xfun(x) + b\n\nNote that this is a general problem specification of a curve fitting problem which can be converted to a linear fit in a specific function space by choosing appropriate xfun and yfun. The yfun_inverse is used to convert the fitted values back to the original space (can be specified by defining InverseFunctions.inverse).\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.PolynomialFitAlgorithm","page":"API","title":"CurveFit.PolynomialFitAlgorithm","text":"PolynomialFitAlgorithm(degree::Int)\nPolynomialFitAlgorithm(;\n    degree::Int,\n    linsolve_algorithm::Union{Nothing, AbstractLinearAlgorithm} = nothing\n)\n\nRepresents a polynomial fitting algorithm of degree degree. Only applicable to LinearCurveFitAlgorithms.\n\ntip: Tip\nFor ill-conditioned problems, it is recommended to use linear solvers like QRFactorization. Alternatively, pass in assumptions = OperatorAssumptions(false; condition = OperatorsCondition.<condition>) to solve/init.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.LogCurveFitAlgorithm","page":"API","title":"CurveFit.LogCurveFitAlgorithm","text":"LogCurveFitAlgorithm()\n\nRepresents a log curve fitting algorithm where x and y are the data points to fit. We want to solve for a and b such that:\n\ny = a * log(x) + b\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.PowerCurveFitAlgorithm","page":"API","title":"CurveFit.PowerCurveFitAlgorithm","text":"PowerCurveFitAlgorithm()\n\nRepresents a power curve fitting algorithm where x and y are the data points to fit. We want to solve for a and b such that:\n\ny = b * x^a\n\nThis is equivalent to a linear fit in log-log space, i.e.,\n\n```math log(y) = a * log(x) + log(b)\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.ExpCurveFitAlgorithm","page":"API","title":"CurveFit.ExpCurveFitAlgorithm","text":"ExpCurveFitAlgorithm()\n\nRepresents an exponential curve fitting algorithm where x and y are the data points to fit. We want to solve for a and b such that:\n\ny = b * exp(a * x)\n\nThis is equivalent to a linear fit in log-linear space, i.e.,\n\nlog(y) = a * x + log(b)\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.RationalPolynomialFitAlgorithm","page":"API","title":"CurveFit.RationalPolynomialFitAlgorithm","text":"RationalPolynomialFitAlgorithm(num_degree::Int, den_degree::Int)\nRationalPolynomialFitAlgorithm(;\n    num_degree::Int, den_degree::Int, alg = nothing\n)\n\nRepresents a rational polynomial fitting algorithm with numerator degree num_degree and denominator degree den_degree. The internal polynomial fitting algorithm is determined by the alg keyword argument. If alg is nothing or a AbstractNonlinearAlgorithm (like solvers from NonlinearSolve.jl), it will use a nonlinear curve fitting approach. If alg is a AbstractLinearAlgorithm, it will use linear least squares fitting.\n\nLinear Rational Polynomial Fitting\n\nIn this case the following curve fit is done:\n\ny = \fracp(x)q(x)\n\nwhere p(x) is a polynomial of degree num_degree and q(x) is a polynomial of degree den_degree. The linear case is solved by doing a least squares fit on:\n\ny * q(x) = p(x)\n\nwhere the zero order term of q(x) is assumed to be 1.\n\nNonlinear Rational Polynomial Fitting\n\nIf an u0 is not provided to the problem, then we will use linear least squares for an initial guess.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.KingCurveFitAlgorithm","page":"API","title":"CurveFit.KingCurveFitAlgorithm","text":"KingCurveFitAlgorithm()\n\nRepresents a king curve fitting problem where x and y are the data points to fit. We want to solve for a and b according to original King's law (1910) that represents the relationship between voltage (E) and velocity (U) in a hotwire anemometer:\n\nE^2 = A + B * U^05\n\nor\n\nx^2 = A + B * y^05\n\n\n\n\n\n","category":"function"},{"location":"api/#CurveFit.ModifiedKingCurveFitAlgorithm","page":"API","title":"CurveFit.ModifiedKingCurveFitAlgorithm","text":"ModifiedKingCurveFitAlgorithm(alg::Union{Nothing, AbstractNonlinearAlgorithm} = nothing)\n\nSimilar to KingCurveFitAlgorithm, but uses the modified King's law:\n\nE^2 = A + B * U^n\n\nwhere n is also a parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#CurveFit.ExpSumFitAlgorithm","page":"API","title":"CurveFit.ExpSumFitAlgorithm","text":"ExpSumFitAlgorithm(; n::Int, m::Int = 1, withconst::Bool = true)\n\nFits the sum of n exponentials and a constant.\n\n    y = k + p_1 e^lambda_1 t + p_2 e^lambda_2 t + ldots + p_n e^lambda_n t\n\nIf the keyword withconst is set to false, the constant is not fitted but set k=0.\n\nUses numerical integration with m strips, where the default m=1 uses linear interpolation. m=2 and higher require uniform interval and usually lead to better accuracy.\n\nThis algorithm is from Matlab code of Juan Gonzales Burgos.\n\n\n\n\n\n","category":"type"},{"location":"api/#Solutions","page":"API","title":"Solutions","text":"","category":"section"},{"location":"api/#CurveFit.CurveFitSolution","page":"API","title":"CurveFit.CurveFitSolution","text":"CurveFitSolution(alg, coeffs, prob)\n\nRepresents the solution to a curve fitting problem. This is a callable struct and can be used to evaluate the solution at a point. Exact evaluation mechanism depends on the algorithm used to solve the problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Common-Interface","page":"API","title":"Common Interface","text":"","category":"section"},{"location":"#CurveFit.jl","page":"Home","title":"CurveFit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Linear, special function, and nonlinear curve fitting in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"CurveFit\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using CurveFit\n\n# Linear fitting\nx = 0:0.1:10\ny = @. 2.5 * x + 3.0 + 0.1 * randn()\n\nprob = CurveFitProblem(x, y, LinearCurveFitAlgorithm())\nsol = solve(prob)","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the API page for detailed documentation of all exported functions.","category":"page"}]
}
